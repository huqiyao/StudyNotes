* [为什么需要节流防抖技术](#为什么需要节流防抖技术)
* [函数防抖Debounce](#函数防抖Debounce)
  * [debounce作用](#debounce作用)
  * [手写防抖](#手写防抖)
* [函数节流Throttle](#函数节流Throttle)
  * [throttle作用](#throttle作用)
  * [手写节流](#手写节流)

- [工具库](#工具库)
  - [lodash](#lodash)



## 为什么需要节流防抖技术

:thought_balloon: 对于频繁触发的事件，通过节流和防抖技术，可以减少事件处理函数被调用的次数。



## 函数防抖 Debounce



### debounce作用

:wrench: 使在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时



### 手写防抖

```typescript
// 写法1
const debounce = (fn, delay)=>{
  // ❓为什么写在这不写在被return的function里面呢？
  let timer
  return function(...args){
    const later = ()=>{
      // 1⃣️delay 时间到了新事件未再触发，later被执行，清除这轮计时
      clearTimeout(timer) // 或者 timer = null，❓二者的区别是什么
      func(...args)
    }
  }
  // 2⃣️delay时间未到但新事件已触发，清除这轮计时，重新赋值计时器开始新一轮计时
  clearTimeout(timer) 
  // 在这赋值了定时器，在 case1⃣️或者2⃣️时被清除
  timer = setTimeout(later, delay) 
}

// 写法2
function debounce(fun, delay) {
    return function (args) {
        let that = this
        let _args = args
        clearTimeout(fun.id)
        fun.id = setTimeout(function () {
            fun.call(that, _args)
        }, delay)
    }
}
```

***:question:问题：***

- 为什么 ```let timer``` 不写在被return的function里面呢
- ```clearTimeout(timer)``` 与 ```timer = null``` 区别



## 函数节流 Throttle



### throttle作用



### 手写节流





## 工具库



### lodash



## 参考

- [1] [levelup资料](https://levelup.gitconnected.com/debounce-in-javascript-improve-your-applications-performance-5b01855e086)

